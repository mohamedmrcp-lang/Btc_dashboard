<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>BTC Personal Trading Dashboard — Fixed</title>
  <script src="https://unpkg.com/lightweight-charts@3.8.0/dist/lightweight-charts.standalone.production.js"></script>
  <style>
    :root{
      --bg:#0b0f14; --panel:#111821; --muted:#7e8a97; --text:#e6eef7;
      --accent:#00d1ff; --up:#22c55e; --down:#ef4444; --warn:#f59e0b;
      --card:#0f1620; --border:#1f2a37;
    }
    *{box-sizing:border-box}
    html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif}
    .container{max-width:1200px;margin:0 auto;padding:16px;display:flex;flex-direction:column;gap:16px}
    .disclaimer{background:linear-gradient(90deg,#1a2431,#1a2431);border:1px solid var(--border);padding:12px 16px;border-radius:14px;font-weight:600;text-align:center;line-height:1.4}
    .top{display:grid;grid-template-columns:1.2fr .8fr;gap:16px}
    @media(max-width:950px){.top{grid-template-columns:1fr}}
    .card{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:16px}
    .hero{display:flex;align-items:center;justify-content:space-between;gap:12px;background:linear-gradient(180deg,#0f1620,#0c121a);border:1px solid var(--border);border-radius:20px;padding:20px}
    .price-block{display:flex;flex-direction:column;gap:8px}
    .price{font-size:40px;font-weight:800;letter-spacing:0.3px}
    .price .small{font-size:14px;color:var(--muted);font-weight:600;margin-left:6px}
    .advice{text-align:right;display:flex;flex-direction:column;gap:8px;min-width:220px}
    .advice .label{font-size:24px;font-weight:900;padding:8px 12px;border-radius:12px;display:inline-block}
    .label.buy{background:rgba(34,197,94,.12);border:1px solid rgba(34,197,94,.4);color:var(--up)}
    .label.sell{background:rgba(239,68,68,.12);border:1px solid rgba(239,68,68,.4);color:var(--down)}
    .label.hold{background:rgba(245,158,11,.12);border:1px solid rgba(245,158,11,.4);color:var(--warn)}
    .confidence{height:8px;background:#0a1017;border-radius:999px;border:1px solid var(--border);position:relative;overflow:hidden}
    .confidence > span{position:absolute;left:0;top:0;height:100%;width:0%;background:linear-gradient(90deg,#ef4444,#f59e0b,#22c55e)}
    .confidence-note{font-size:12px;color:var(--muted);margin-top:6px}
    .stats{display:grid;grid-template-columns:repeat(5,1fr);gap:10px;margin-top:10px}
    @media(max-width:800px){.stats{grid-template-columns:repeat(2,1fr)}}
    .stat{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:12px}
    .stat .k{font-size:12px;color:var(--muted)}
    .stat .v{font-size:18px;font-weight:800;margin-top:4px}
    .toolbar{display:flex;align-items:center;justify-content:space-between;margin-bottom:10px;gap:10px}
    .tf{display:flex;gap:8px}
    .btn{padding:8px 12px;border-radius:10px;border:1px solid var(--border);color:var(--text);background:#0e141c;cursor:pointer;font-weight:700}
    .btn.active{border-color:var(--accent);color:var(--accent);box-shadow:0 0 0 2px rgba(0,209,255,.08) inset}
    #chart{height:420px}
    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:16px}
    @media(max-width:950px){.grid2{grid-template-columns:1fr}}
    .gauge-wrap{display:flex;flex-direction:column;gap:10px}
    .gauge{position:relative;height:22px;border-radius:999px;background:linear-gradient(90deg,#ef4444,#f59e0b,#22c55e);overflow:hidden;border:1px solid var(--border)}
    .gauge-pointer{position:absolute;top:-4px;width:2px;height:30px;background:#fff;left:50%;transform:translateX(-50%);box-shadow:0 0 8px rgba(255,255,255,.6)}
    .gauge-legend{display:flex;justify-content:space-between;font-size:12px;color:var(--muted)}
    .indicators{display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
    @media(max-width:800px){.indicators{grid-template-columns:1fr}}
    .ind-card{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:12px}
    .ind-title{font-size:12px;color:var(--muted);font-weight:700}
    .ind-value{font-size:20px;font-weight:900;margin-top:4px}
    .up{color:var(--up)} .down{color:var(--down)}
    .foot{text-align:center;color:var(--muted);font-size:12px}
    a,button{outline:none}
    .loading{text-align:center;padding:20px;color:var(--muted)}
    .error{background:rgba(239,68,68,0.1);border:1px solid var(--down);color:var(--down);padding:12px;border-radius:8px;margin:10px 0}
  </style>
</head>
<body>
  <div class="container">
    <div class="disclaimer"> This is an automated technical analysis </div>

    <div class="top">
      <div class="hero card">
        <div class="price-block">
          <div class="price" id="bigPrice">$— <span class="small" id="priceChange">24h: —%</span></div>
          <div class="stats">
            <div class="stat"><div class="k">24h High</div><div class="v" id="high24">—</div></div>
            <div class="stat"><div class="k">24h Low</div><div class="v" id="low24">—</div></div>
            <div class="stat"><div class="k">24h Volume</div><div class="v" id="vol24">—</div></div>
            <div class="stat"><div class="k">Market Cap</div><div class="v" id="mcap">—</div></div>
            <div class="stat"><div class="k">Last Updated</div><div class="v" id="updated">—</div></div>
          </div>
        </div>

        <div class="advice">
          <div id="adviceLabel" class="label hold">HOLD: Awaiting clearer signal.</div>
          <div class="confidence"><span id="confBar"></span></div>
          <div class="confidence-note" id="confText">Confidence: —</div>
        </div>
      </div>

      <div class="card">
        <div class="gauge-wrap">
          <div style="display:flex;justify-content:space-between;align-items:center"><strong>Sentiment Gauge</strong><span id="sentimentText" style="color:var(--muted)">—</span></div>
          <div class="gauge"><div class="gauge-pointer" id="gaugePointer" style="left:50%"></div></div>
          <div class="gauge-legend"><span>Extreme Fear</span><span>Neutral</span><span>Extreme Greed</span></div>

          <div class="indicators">
            <div class="ind-card"><div class="ind-title">RSI(14)</div><div class="ind-value" id="rsiVal">—</div></div>
            <div class="ind-card"><div class="ind-title">MACD 12/26/9</div><div class="ind-value"><span id="macdVal">—</span> <span class="small" id="macdSig" style="margin-left:8px;color:var(--muted)">—</span></div></div>
            <div class="ind-card"><div class="ind-title">SMA50 / SMA200</div><div class="ind-value" id="smaVal">—</div></div>
          </div>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="toolbar">
        <div><strong>BTCUSD — Main Chart</strong></div>
        <div class="tf">
          <button class="btn active" data-tf="5m">5m</button>
          <button class="btn" data-tf="1h">1h</button>
          <button class="btn" data-tf="1d">1d</button>
        </div>
      </div>
      <div id="chart">
        <div class="loading" id="chartLoading">Loading chart data...</div>
      </div>
    </div>

    <div class="card">
      <strong>Notes</strong>
      <ul style="margin-top:8px;color:var(--muted);line-height:1.6">
        <li>Price refreshes every 10 seconds via CoinGecko.</li>
        <li>Chart uses TradingView Lightweight Charts (client-side only).</li>
        <li>Signals aggregate RSI, MACD, and SMA cross + price vs MA positioning.</li>
        <li>Confidence is an estimate based on indicator alignment — not a guarantee.</li>
      </ul>
    </div>
</div>
    <div class="foot">Data source: CoinGecko • Chart: TradingView Lightweight Charts™</div>
  </div>

  <script>
  /********************************************************************************
   * Fixed BTC dashboard with:
   * - Corrected API endpoints
   * - Improved error handling
   * - Fixed indicator calculations
   * - Better initialization process
   ********************************************************************************/

  // --- Helpers / formatters ---
  const $ = (id) => document.getElementById(id);
  const fmtUSDCompact = (n) => {
    if (n == null || isNaN(n)) return '—';
    if (n >= 1e12) return '$' + (n/1e12).toFixed(2) + 'T';
    if (n >= 1e9) return '$' + (n/1e9).toFixed(2) + 'B';
    if (n >= 1e6) return '$' + (n/1e6).toFixed(2) + 'M';
    if (n >= 1e3) return '$' + (n/1e3).toFixed(0) + 'K';
    return '$' + Number(n).toLocaleString(undefined, { maximumFractionDigits: 2 });
  };
  const fmtPrice = (n) => n == null || isNaN(n) ? '$—' : '$' + Number(n).toLocaleString(undefined, { minimumFractionDigits:2, maximumFractionDigits:2 });
  const nowStr = (iso) => iso ? new Date(iso).toLocaleString() : '—';

  // --- DOM references ---
  const bigPrice = $('bigPrice');
  const priceChange = $('priceChange');
  const high24 = $('high24'), low24 = $('low24'), vol24 = $('vol24'), mcap = $('mcap'), updated = $('updated');
  const adviceLabel = $('adviceLabel'), confBar = $('confBar'), confText = $('confText');
  const gaugePointer = $('gaugePointer'), sentimentText = $('sentimentText');
  const rsiVal = $('rsiVal'), macdVal = $('macdVal'), macdSig = $('macdSig'), smaVal = $('smaVal');
  const chartLoading = $('chartLoading');

  // --- Chart setup ---
  let chart, candleSeries, sma50Line, sma200Line;
  
  function initChart() {
    const chartContainer = $('chart');
    chartContainer.innerHTML = ''; // Clear loading message
    
    chart = LightweightCharts.createChart(chartContainer, {
      layout: { background: { color: 'transparent' }, textColor: '#e6eef7' },
      rightPriceScale: { borderVisible: false },
      timeScale: { borderVisible: false, timeVisible: true, secondsVisible: false },
      grid: { vertLines: { color: 'rgba(255,255,255,0.03)' }, horzLines: { color: 'rgba(255,255,255,0.03)' } },
      crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
      localization: { priceFormatter: p => '$' + p.toFixed(2) }
    });
    
    candleSeries = chart.addCandlestickSeries({
      upColor:'#22c55e', downColor:'#ef4444', borderVisible:false, 
      wickUpColor:'#22c55e', wickDownColor:'#ef4444'
    });
    
    sma50Line = chart.addLineSeries({ color:'#00d1ff', lineWidth:1.6 });
    sma200Line = chart.addLineSeries({ color:'#7e8a97', lineWidth:1.6 });

    new ResizeObserver(() => chart.timeScale().fitContent()).observe(chartContainer);
  }

  // --- CoinGecko endpoints & config ---
  const CG = {
    // Updated API endpoints
    ticker: 'https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd&include_24hr_change=true&include_last_updated_at=true&include_24hr_vol=true&include_24hr_high_low=true&include_market_cap=true',
    ohlc: (days) => `https://api.coingecko.com/api/v3/coins/bitcoin/ohlc?vs_currency=usd&days=${days}`
  };
  
  const TF_CFG = {
    '5m': { days: 1, interval: '5m' },
    '1h': { days: 7, interval: '1h' },
    '1d': { days: 365, interval: '1d' }
  };

  // --- Indicator functions ---
  function SMA(values, period){
    const out = Array(values.length).fill(null);
    if(values.length < period) return out;
    let sum = 0;
    for(let i=0;i<values.length;i++){
      sum += values[i];
      if(i >= period) sum -= values[i-period];
      if(i >= period - 1) out[i] = sum / period;
    }
    return out;
  }
  
  function EMA(values, period){
    const out = Array(values.length).fill(null);
    if(values.length === 0) return out;
    let ema = values[0];
    out[0] = ema;
    const k = 2/(period+1);
    for(let i=1;i<values.length;i++){
      ema = values[i]*k + ema*(1-k);
      out[i] = ema;
    }
    return out;
  }
  
  function RSI(values, period=14){
    const out = Array(values.length).fill(null);
    if(values.length <= period) return out;
    
    let gains = 0, losses = 0;
    for(let i=1;i<=period;i++){
      const change = values[i] - values[i-1];
      if(change >= 0) gains += change;
      else losses -= change;
    }
    
    let avgGain = gains/period;
    let avgLoss = losses/period;
    
    for(let i=period+1;i<values.length;i++){
      const change = values[i] - values[i-1];
      const gain = change > 0 ? change : 0;
      const loss = change < 0 ? -change : 0;
      
      avgGain = (avgGain*(period-1) + gain)/period;
      avgLoss = (avgLoss*(period-1) + loss)/period;
      
      const rs = avgGain/avgLoss;
      out[i] = 100 - (100/(1+rs));
    }
    
    return out;
  }
  
  function MACD(values, fast=12, slow=26, signal=9){
    const emaFast = EMA(values, fast);
    const emaSlow = EMA(values, slow);
    const macdLine = values.map((_, i) => 
      (emaFast[i] !== null && emaSlow[i] !== null) ? emaFast[i] - emaSlow[i] : null
    );
    
    // Clean null values for signal calculation
    const cleanMacd = macdLine.map(v => v === null ? 0 : v);
    const signalLine = EMA(cleanMacd, signal);
    
    const histogram = macdLine.map((v, i) => 
      (v !== null && signalLine[i] !== null) ? v - signalLine[i] : null
    );
    
    return { macd: macdLine, signal: signalLine, hist: histogram };
  }

  // --- Data processing ---
  function processOHLCData(data, intervalMs) {
    return data.map(item => ({
      time: Math.floor(item[0] / 1000), // Convert to seconds
      open: item[1],
      high: item[2],
      low: item[3],
      close: item[4]
    })).sort((a, b) => a.time - b.time);
  }

  // --- State ---
  let candleCache = { '5m': [], '1h': [], '1d': [] };
  let currentTF = '5m';

  // --- Fetchers ---
  async function getTicker(){
    try {
      const res = await fetch(CG.ticker, { cache: 'no-store' });
      if(!res.ok) throw new Error('Ticker fetch failed');
      const data = await res.json();
      const btc = data.bitcoin;
      
      return {
        price: btc.usd,
        high: btc.usd_24h_high,
        low: btc.usd_24h_low,
        volume: btc.usd_24h_vol,
        mcap: btc.usd_market_cap,
        changePct: btc.usd_24h_change,
        updatedAt: new Date(btc.last_updated_at * 1000).toISOString()
      };
    } catch(err) {
      console.error('Ticker fetch error:', err);
      showError('Failed to fetch price data. Please check your connection.');
      return null;
    }
  }

  async function getOHLC(days){
    try {
      const res = await fetch(CG.ohlc(days), { cache: 'no-store' });
      if(!res.ok) throw new Error('OHLC fetch failed');
      return await res.json();
    } catch(err) {
      console.error('OHLC fetch error:', err);
      showError('Failed to fetch chart data. Please try again later.');
      return [];
    }
  }

  function showError(message) {
    // Remove any existing errors
    const existingError = document.querySelector('.error');
    if (existingError) existingError.remove();
    
    const errorDiv = document.createElement('div');
    errorDiv.className = 'error';
    errorDiv.textContent = message;
    document.querySelector('.container').insertBefore(errorDiv, document.querySelector('.foot'));
    
    // Auto-remove after 5 seconds
    setTimeout(() => {
      if (errorDiv.parentNode) errorDiv.parentNode.removeChild(errorDiv);
    }, 5000);
  }

  // --- TA / Advice / UI Updates ---
  function computeTAFromCandles(candles){
    if(!candles || !candles.length) return null;
    
    const closes = candles.map(c => c.close);
    const times = candles.map(c => c.time);

    const sma50 = SMA(closes, 50);
    const sma200 = SMA(closes, 200);
    const rsi14 = RSI(closes, 14);
    const macdObj = MACD(closes, 12, 26, 9);

    const last = closes.length - 1;
    const price = closes[last];
    const rsi = rsi14[last];
    const macd = macdObj.macd[last];
    const signal = macdObj.signal[last];
    const hist = macdObj.hist[last];
    const s50 = sma50[last];
    const s200 = sma200[last];

    let bull = 0, bear = 0;

    // RSI analysis
    if(rsi != null){
      if(rsi < 30) bull++;
      else if(rsi > 70) bear++;
    }
    
    // MACD analysis
    if(macd != null && signal != null){
      if(macd > signal && hist > 0) bull++;
      else if(macd < signal && hist < 0) bear++;
    }
    
    // SMA analysis
    if(s50 != null && s200 != null){
      if(s50 > s200) bull++; 
      else if(s50 < s200) bear++;
      
      if(price > s50 && price > s200) bull++; 
      else if(price < s50 && price < s200) bear++;
    }

    // Generate advice
    let advice = 'HOLD: Awaiting clearer signal.', klass = 'hold';
    if(bull >= 3 && bear === 0){ 
      advice = `STRONG BUY: ${fmtPrice(price)}`; 
      klass = 'buy'; 
    }
    else if(bear >= 3 && bull === 0){ 
      advice = `STRONG SELL: ${fmtPrice(price)}`; 
      klass = 'sell'; 
    }
    else if(bull === 1 && bear === 0){ 
      advice = `WEAK BUY: ${fmtPrice(price)}`; 
      klass = 'buy'; 
    }
    else if(bear === 1 && bull === 0){ 
      advice = `WEAK SELL: ${fmtPrice(price)}`; 
      klass = 'sell'; 
    }
    else if(bull > bear && (bull - bear) >= 2){ 
      advice = `WEAK BUY: ${fmtPrice(price)}`; 
      klass = 'buy'; 
    }
    else if(bear > bull && (bear - bull) >= 2){ 
      advice = `WEAK SELL: ${fmtPrice(price)}`; 
      klass = 'sell'; 
    }

    // Confidence calculation
    const confidence = Math.round((Math.max(bull, bear) / 4) * 100);

    // Sentiment gauge (0 fear -> 100 greed)
    let gauge = 50;
    if(rsi != null) gauge = 0.6 * rsi + 20;
    if(macd != null && signal != null) gauge += (macd - signal) * 80;
    if(s50 != null && s200 != null) gauge += (s50 > s200 ? 6 : -6);
    gauge = Math.max(0, Math.min(100, gauge));

    return { 
      advice, klass, confidence, gauge, price, 
      rsi, macd, signal, hist, s50, s200 
    };
  }

  function updateUIFromTA(ta){
    if(!ta) return;
    
    // Update advice
    adviceLabel.classList.remove('buy','sell','hold');
    adviceLabel.classList.add(ta.klass);
    adviceLabel.textContent = ta.advice;
    
    // Update confidence
    confBar.style.width = `${ta.confidence}%`;
    confText.textContent = `Confidence: ~${ta.confidence}%`;
    
    // Update indicators
    rsiVal.textContent = ta.rsi != null ? ta.rsi.toFixed(2) : '—';
    rsiVal.className = 'ind-value' + (ta.rsi > 70 ? ' down' : ta.rsi < 30 ? ' up' : '');
    
    macdVal.textContent = (ta.macd != null && ta.signal != null) ? 
      `${ta.macd.toFixed(4)} / ${ta.signal.toFixed(4)}` : '—';
    
    macdSig.textContent = ta.hist != null ? `Hist: ${ta.hist.toFixed(4)}` : '—';
    
    smaVal.textContent = (ta.s50 != null || ta.s200 != null) ? 
      `${ta.s50 ? ta.s50.toFixed(2) : '—'} / ${ta.s200 ? ta.s200.toFixed(2) : '—'}` : '—';
    
    // Update sentiment
    let sentiment;
    if (ta.gauge <= 20) sentiment = 'Extreme Fear';
    else if (ta.gauge <= 40) sentiment = 'Fear';
    else if (ta.gauge >= 80) sentiment = 'Extreme Greed';
    else if (ta.gauge >= 60) sentiment = 'Greed';
    else sentiment = 'Neutral';
    
    sentimentText.textContent = `${sentiment} (${Math.round(ta.gauge)})`;
    gaugePointer.style.left = `${ta.gauge}%`;
  }

  // --- Load chart for given timeframe ---
  async function loadTimeframe(tf){
    try {
      currentTF = tf;
      document.querySelectorAll('.btn[data-tf]').forEach(b => 
        b.classList.toggle('active', b.getAttribute('data-tf') === tf)
      );
      
      const cfg = TF_CFG[tf];
      const rawData = await getOHLC(cfg.days);
      
      if (!rawData || !rawData.length) {
        showError('No chart data available. Please try again later.');
        return;
      }
      
      // Process OHLC data
      const intervalMs = tf === '5m' ? 300000 : tf === '1h' ? 3600000 : 86400000;
      const candles = processOHLCData(rawData, intervalMs);
      candleCache[tf] = candles;
      
      // Initialize chart if not already done
      if (!chart) initChart();
      
      // Update chart series
      candleSeries.setData(candles);
      
      // Calculate and set SMA lines
      const closes = candles.map(c => c.close);
      const times = candles.map(c => c.time);
      
      const s50 = SMA(closes, 50);
      const s200 = SMA(closes, 200);
      
      const s50Data = [], s200Data = [];
      for(let i = 0; i < times.length; i++){
        if(s50[i] != null) s50Data.push({ time: times[i], value: s50[i] });
        if(s200[i] != null) s200Data.push({ time: times[i], value: s200[i] });
      }
      
      sma50Line.setData(s50Data);
      sma200Line.setData(s200Data);
      
      // Calculate and update TA
      const ta = computeTAFromCandles(candles);
      updateUIFromTA(ta);
      
      // Fit content to view
      chart.timeScale().fitContent();
      
    } catch(err) {
      console.error('loadTimeframe error', err);
      showError('Failed to load chart. Please try again.');
    }
  }

  // --- Ticker refresh & live update ---
  async function refreshTicker(){
    try {
      const t = await getTicker();
      if (!t) return;
      
      // Update price display
      bigPrice.innerHTML = `${fmtPrice(t.price)} <span class="small">24h: ${(t.changePct >= 0 ? '+' : '') + t.changePct.toFixed(2)}%</span>`;
      priceChange.textContent = `24h: ${(t.changePct >= 0 ? '+' : '') + t.changePct.toFixed(2)}%`;
      priceChange.style.color = (t.changePct >= 0) ? 'var(--up)' : 'var(--down)';
      
      // Update stats
      high24.textContent = fmtPrice(t.high);
      low24.textContent = fmtPrice(t.low);
      vol24.textContent = fmtUSDCompact(t.volume);
      mcap.textContent = fmtUSDCompact(t.mcap);
      updated.textContent = nowStr(t.updatedAt);
      
      // Update current candle with live price
      const candles = candleCache[currentTF];
      if(candles && candles.length){
        const lastCandle = candles[candles.length - 1];
        const updatedCandle = {
          ...lastCandle,
          close: t.price,
          high: Math.max(lastCandle.high, t.price),
          low: Math.min(lastCandle.low, t.price)
        };
        
        candleSeries.update(updatedCandle);
        
        // Recalculate TA with updated price
        const updatedCandles = [...candles];
        updatedCandles[updatedCandles.length - 1] = updatedCandle;
        
        const ta = computeTAFromCandles(updatedCandles);
        updateUIFromTA(ta);
      }
    } catch(err) {
      console.warn('refreshTicker error', err);
    }
  }

  // --- TF buttons wiring ---
  document.querySelectorAll('.btn[data-tf]').forEach(btn => {
    btn.addEventListener('click', async () => {
      const tf = btn.getAttribute('data-tf');
      if(tf === currentTF) return;
      await loadTimeframe(tf);
    });
  });

  // --- Initialization & loops ---
  (async function init(){
    // Initialize chart first
    initChart();
    
    // Load initial data
    await loadTimeframe('5m');
    await refreshTicker();
    
    // Set up intervals
    setInterval(refreshTicker, 10000); // Every 10 seconds
    setInterval(() => loadTimeframe(currentTF), 60000); // Every minute
  })();
  </script>
</body>
</html>
